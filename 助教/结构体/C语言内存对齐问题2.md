# [C语言内存对齐详解](http://www.cnblogs.com/wuyudong/p/memory-alignment.html)

## 一、字节对齐基本概念

    现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。 对齐的作用和原因：各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问一个没有进行对齐的变量的时候会发生错误,那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那 么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。

 本文地址：[http://www.cnblogs.com/archimedes/p/memory-alignment.html](http://www.cnblogs.com/archimedes/p/memory-alignment.html)，转载请注明源地址。

请看下面的结构：

```
struct struct1 
{ 
   double dda; 
   char cda; 
   int ida; 
}; 
```

sizeof(struct1) = ?

错误的求法：

sizeof(struct1)=sizeof(double)+sizeof(char)+sizeof(int)=13

但是当你运行如下测试代码：

```
#include<stdio.h>
struct mystruct
{
    double dda;
    char cda;
    int ida;
};

int main()
{
    struct mystruct ss;
    printf("%d\n",sizeof(ss));
    return 0;
}
```

运行结果为：16

其实，这是编译器对变量存储的一个特殊处理。为了提高CPU的存储速度，编译器对一些变量的起始地址做了“对齐”处理。在默认情况下，编译器规定各成员变量存放的起始地址相对于结构的起始地址的偏移量必须为该变量的类型所占用的字节数的倍数。下面列出常用类型的对齐方式：

类型            对齐方式（变量存放的起始地址相对于结构的起始地址的偏移量）

char              偏移量必须为sizeof(char)即1的倍数

int                偏移量必须为sizeof(int)即4的倍数

float             偏移量必须为sizeof(float)即4的倍数

double          偏移量必须为sizeof(double)即8的倍数

Short            偏移量必须为sizeof(short)即2的倍数

------

各成员变量在存放的时候根据在结构中出现的顺序依次申请空间，同时按照上面的对齐方式调整位置，空缺的字节编译器会自动填充。同时编译器为了确保结构的大小为结构的字节边界数（即该结构中占用最大空间的类型所占用的字节数）的倍数，所以在为最后一个成员变量申请空间后，还会根据需要自动填充空缺的字节

现在来分析编译器是怎样来存放结构的：

```
struct struct1 
{ 
   double dda; 
   char cda; 
   int ida; 
}; 
```

第一个成员dda分配空间，其起始地址跟结构的起始地址相同（偏移量0刚好为sizeof(double)的倍数），该成员变量占用sizeof(double)=8个字节；

接下来为第二个成员cda分配空间，这时下一个可以分配的地址对于结构的起始地址的偏移量为8，是sizeof(char)的倍数，所以把cda存放在偏移量为8的地方满足对齐方式，该成员变量占用 sizeof(char)=1个字节；

接下来为第三个成员ida分配空间，这时下一个可以分配的地址对于结构的起始地址的偏移量为9，不是sizeof (int)=4的倍数，为了满足对齐方式对偏移量的约束问题，VC自动填充3个字节（这三个字节没有放什么东西），这时下一个可以分配的地址对于结构的起始地址的偏移量为12，刚好是sizeof(int)=4的倍数，所以把ida存放在偏移量为12的地方，该成员变量占用sizeof(int)=4个字节；这时整个结构的成员变量已经都分配了空间，总的占用的空间大小为：8+1+3+4=16，刚好为结构的字节边界数（即结构中占用最大空间的类型所占用的字节数sizeof(double)=8）的倍数，没有空缺的字节需要填充。

所以整个结构的大小为：sizeof(struct1)=8+1+ 3+4=16，其中有3个字节是VC自动填充的，没有放任何有意义的东西。



下面再举个例子，交换一下上面的struct1的成员变量的位置，使它变成下面的情况：

```
struct mystruct2
{
    char cda;
    double dda;
    int ida;
};
```

 运行结果为：24

```
struct mystruct2
{
    char cda;    //偏移量为0，满足对齐方式，cda占用1个字节；
    double dda;  //下一个可用的地址的偏移量为1，不是sizeof(double)=8 
                 //的倍数，需要补足7个字节才能使偏移量变为8（满足对齐 
                 //方式），因此VC自动填充7个字节，dda存放在偏移量为8 
                 //的地址上，它占用8个字节。 

    int ida;     //下一个可用的地址的偏移量为16，是sizeof(int)=4的倍 
                 //数，满足int的对齐方式，所以不需要VC自动填充，type存 
                 //放在偏移量为16的地址上，它占用4个字节。
   
   //所有成员变量都分配了空间，空间总的大小为1+7+8+4=20，不是结构 
   //的节边界数（即结构中占用最大空间的类型所占用的字节数sizeof 
   //(double)=8）的倍数，所以需要填充4个字节，以满足结构的大小为 
   //sizeof(double)=8的倍数。
};
```

 所以该结构总的大小为：sizeof(struct2)为1+7+8+4+4=24。其中总的有7+4=11个字节是VC自动填充的，没有放任何有意义的东西。